# Leadership principles
## Achivements
1. Rebuild orderbook application.  
   Questions: Most difficult project you worked on?
   
    Situation:   
    The most difficult project I worked on was to rebuild the applcation for order book trade. The company had a legacy application that was developed 20 years ago using old technologies. As a result, the appliation was very hard to maintain and to extend. Adding new functionality turned out very challenging and time-consuming. Its performance was not great either. So I was tasked to lead a team of 8 people including developers, testers, and a business person to rewrite the legacy application.
    
    Task:  
    The biggest challenge was to understand the business requirement. Given the legacy application was 20 years old, and many people who originally worked on it had left, and there was hardly any documentation, hence no one had a comprehensive understanding of the application.
   
   The second challenage was to have a good design so the system could be maintained and extend easily in the future.

    And the third one is to really lead the team to finish the project within the deadline.
    
    Action:  
    To understand how existing application works, I communicated with all the relevant parties from various teams who had bits of knowledge of it including business team, market operation team and development team, and wrote the requirement down in a shared workspace, and then asked them to review as well. I also spent a lot of time in checking how the existing application worked as well by testing and looking at the code directly. After a few weeks a clear and detailed business requirement was written and the team had a shared understanding of it as well. 
    
    Then I did an investigation into the technologies and came up with a design that utilized micro service architecture and springboot framework to improve productivity and increase scalibility. I also made sure the design was clearly documentated in details so future developers could understand it easily.

    Finally I set a few major milestones, divided the project into many smaller tasks and worked with the team. I also tracked the project progress on a daily basis and made sure the blocking issues were resolved quickly and the project was on track.
    
    Result:  
    Eventually the project finished successfully. Although the code change was enormous, the appliation had very few issues since it went live. And some new functionalities were also well received by the clients and as a result the revenue increased by 10%. 

3. Invented a new way for database migration which boosted team productivity and morale

   Situation:
   When I joined my previous company a few years ago, I noticed the process of database migration was a quite manual and tedious one. We had various databases for different environment from UAT, DEMO to production etc., and each developer could have a few databases as well for different tasks. Each time when there was a database change, it needed to be applied manually to other different databases as well so they can be in sync. Not only this was quite slow but also it was very error-prone. Although the other developers who had worked there alreday complained about this as well, some of them were kind of used to it and no one really attempted to solve the problem. 

   Task:
   As a new comer, I was really not happy with this status quo and I was keen to find a more simple and efficient way for database migration. 

   Action:
   I explained the problem to my manager and mentioned the issue would getting much worse with more environments being added and more developers joining the company later and if left unchecked, the issue would not only decrease developer's productivity significantly but also affected the team morale a lot. I told my manager that I would like to spend some time to find a better solution and he approved. So I did a lot of investigation and found liquibase a open-source libarary for tracking, managinging and applying database changes. Liquibase defined database changes in various format that were familar and comfortable to developers, SQL, XML, JSON at etc. The changes could be in a code reposotory hence could be tracked easily. And the change could be applied to database using auto deployment tools like Jenkins. I tested this new approach for database migration and it worked well.


   Result:  
   After a week, I formalized the process for databse migration. Then I gave a DEMO to fellow developers showing how database migration can be done easily using this new process. They were very impressed. The team agreed this was a much better way for database migration. So I clearly documentated how to follow the new process and the team fully adopted to it. Several weeks later, I asked feedback to other develoeprs, and they said on average at least 4 hours were saved for them a week. So to summarize, I noticed a problem which affected developer's productivity significantly, and took initiative to invent a simple yet very efficient process which increased productivity a lot.

4. Worked on tight deadline  
   Situation:  
   I have faced quite a few instances in my career where I have had to work to tight deadlines. However, one occasion that particularly stands out was during my tenure as a Lead Software Developer at my previous organization. We were working on a major product luanch but midway through the project, our senior management maded the difficult decision to move the deadline up by a few weeks, due to change of the market condition. This left us with significant amount of work to complete in a much shorter time frame.

   Task:
   So the challenge was how to finish the work within the deadline.

   Action:
   To tackle the challenge, I did a few things.
   
   Firstly, I sat down with the team and re-evaluated our project timeline. It was essential for everyone to understand the situation we were in and the new expectations. I then strategically prioritized the tasks based on their impact on the project, identifying which tasks could be done concurrently and which tasks were dependent on others.

   Secondly, I identified several developers from other teams that could help the project based on their experience and skillset. Then I asked the management to allow them pause what they worked and helped on the project for a while and the request was approved.
   
   Thirdly, I discussed with the team and suggested to put in some extra hours each week. I explained to the team that no one liked working overtime, but this was really needed in such a critical time. So all the team members agreed to put extra hours every week. I ensured that this was done on a rotational basis to avoid burnout and maintained an open line of communication for any team member to express concerns or issues.
   
      After this, I implemented a more rigorous daily check-in to keep track of the projectâ€™s progress. This not only helped in identifying any potential roadblocks early but also ensured that everyone was aligned on the project status and the tasks they were responsible for. 
   
   Simultaneously, I kept the management informed of our progress. Transparency was crucial, so we made sure to provide regular updates, reassuring them that we were doing our utmost to meet the revised deadline.

   Result:  
   Eventually, I was able to lead the project to completion on time without compromising on the quality of our work. It was a very challenging period, but it underscored the importance of strategic planning, effective communication, and teamwork when working under tight deadlines.

5. Improved release process  
   Situation:  
   A few years ago, I noticed the release process in our company was becoming less effective. We had more than 20 applications and for each application, it had several instances running on different linux servers. And for each application, there was a separate CI/CD tool Jenkins to package the application and move the files to the linux servers, and the release also involved a manual step of executing commands on the different linux servers to restart services to avoid that people accidentllay restarting the service. As you can imagine, it would be very time-consuming to release all these applications and in fact it could take 4 hours or sometimes even a day for a developer. More importantly, this manual process was very error-prone as sometimes people forgot some steps. Many people was not happy with the release process but not person took the initiative to solve the problem.
   
   Task:  
   Having witnessed the inefficiency of the release process for a while, I really wanted to improve it and explaind the situation to the management and hence got approval to spend some time on it.
   
   Actions:  
   I did an investigation and checked what was the latest industry standard for release process. I found it was very common to have automatic release process using some CI/CD tool like Jenkins and Jenkins offered powerful solution for automating software delivery processes. I spent a few days creating a Jenkins pipeline script which allowed to package all or some of the applications and then deploying them in one go. To avoid the risk that people accidently triggering the release process, I made some configuration change so that only a few senior people were granted permission to view and trigger the Jenkins job to release to production. For others, the permission can be granted on a need basis. I then tested the new release process in a testing environment for several days and later I proposed the release process to the wide team.
   
   Result:  
   The team including the management were very impressed. Not long after, the team formally adopted the new release process. It turned out the release process worked very well . It reduced the time people spent on deploying changes to production by 3 hours per release, and in the meantime mitigated the risk of human error.

## Disagree and commit
1. Disagree with project delivery plan  
   Situation:
   When I worked on the project to rewrite our system for orderbook trading of bonds, I disagreed with the business people about the delivery approach. We had bonds products and the most important ones for the company were government bonds and business people wanted the system to be deployed in a big bang approach and then worked for bonds straight away. I disagreed with this approach because I believed the risk was too high and I suggested to release the system in several stages instead.
   
   Tasks:
   So the task I have was to discuss with business people and find the the right approach for delivery.
   
   Actions:
   I did a few things. 
   
   Firstly I clearly explained the risks that were involved:
   1. The system was super complex and it touched many different applications and the likelihood. Although we did a lot of testing, but it just couldn't cover everything so the likelihood of something functionality was broken was high from technical point of view
   
   Then I mentioned the consequences of having something broken. Govenment bonds were the main products on our platform and generated the most revenue for our company. If there were serious issues, not only the revenue would be affected, but the reputation of our company as a trading platform would be damaged and we may potentially have some legal problem as well. 
   
   So I proposed to release the system in three major stages to control the risk and have rapid delivery as well:
   1. In the first stage, we had the system functionalities behind feature toggles, and released it with the functionalities turned off. This was really to make sure there was some regression impact.
   2. In the second stage, we released the system for a not so important products, inflation linked bonds. This was to make sure the main funcionality worked because the inflation linked bonds worked very similarly to government bonds.
   3. In the third stage, we released the system for our most important products, government bonds.
   
   Result:
   In the end, the business people agreed with me on the delivery approach. The system was deliverred successfully to production in multiple stages and no major issues were introduced. The team was really happy with this approach of having functionatility behind feature toggles and delivering to production more rapidly, and different teams were advised to follow this approach as well.

1. Disagree with coding standard  
   Situation:
   I once noticed some problems of code not being clean when performing the code review. The code was not formatted well such as there was not spaces between operand and operator, and one line if statement were not enclosed with brackets, code was duplicated, etc. I advised the person to change accordingly but the person disagreed.
   
   Tasks:
   So the task was to discuss with that person and find ways to improve the code.
   
   Action:
   I clearly explained the principles of clean code and why they were important, referencing the industry standard code guideline as well, such as the Google code style guide. For example, having proper spaces would make the code much easier to read. Having brackets around one life if statement would make the code easy to maintain as the code would still work if in the future someone adds a new line for the if statement. Encapsulating duplicated code would make the logic clear, and it can be reused easily as well in the future. 
   
   Then I suggested to configure the development tool IDE to have automatic code formatting so no need to worry the issue such as not having proper spaces at all. And I suggested to have linting tool installed as well so it can detect some potential code issue for refactoring. For example, it can defect code duplication and suggest to encapsulate the logic into a small function.
   
   I also took the chance to propose giving a presentation to the much wider development team to raise awareness of principles of clean code.
   
   Result:
   Finally my manager agreed with me, changed the code accordingly and approved me to give a presentation to the much wider development team. And the presentation was well received and they were happy to follow the principles of clean code. A month later, we reviewed the code commits from various developers and found that the code quality improved significantly, with code formatting issues decreased by 50%.

1. Disagree with whether developers should write unit test and conduct thorough manual testing as well  
   Situation:  
   Several years ago I noticed that there was a tendency to neglect testing for developers in the team. When developers worked on a new fuctionality or fixing a defect, there was not much unit test or automation test, and there was no clear evidence that developers did enough manual testing either. I was a big believer that developers should be responsible for the quality of their code include testing the code as well, before handing over to the quality assurance team or testers. The management thought developers could focus on the delivery and let testers test the functionality more thoroughly as it would be time-consuming for developers to write unit test, automated end-to-end tests, or tested the functionality throughly.
   
   Tasks:  
   I strongly disagreed with the status quo and tried very hard to persuade the management to realize the importance of having more test from developers.
   
   Action:  
   I firstly explained the importance of unit test. Unit tests could catch defects early in the release process. It can also improve code quality and facilitate refactoring in the future. For example, when some code is refactored, if a unit test fails, then likely some existing functionality is broken and should be fixed accordingly. Unit tests can also serve as a documenation to help developers understand the code. I used existing code as an exmaple and provoided some unit tests to show how it would help us. 
   
   I then explained the importance of manual testing by developers. I mentioned that developers should write clear test scenarios and put evidence of what tests were conducted as well. That way testers can look at the test scenario and test evidence, and may focus more on the scenarios that were not tested thoroughly instead of testing everything blindly, which would be very time-consuming and ineffective in finding defects. 
   
   Result:  
   The management was finally persuaded and asked developers to try this new approach of writing unit test code and conducting manual test and documenting testing evidence as well to see how it worked. After a few weeks, the feedback from the developers were that the found the overall code quality improved, and there were less pushbacks from testers for rework. For testers, the time required to verify a fuctionality for bug-fix decreased by roughly 30%. So the management saw the benefits and hence formally asked all developers to follow this process from then on and we never looked upon.


## Failures
1. Missed a deadline
   Situation:  
   I recall I once missed a deadline during early days of my career. Back then, I worked extremely hard and was often overly eager to go to the extra mile. Then I was asked to lead a small team to work on a feature for one of our clients. It was my first time leading a project, so I was very keen to  prove myself. However, I neglected the fact that the client had very high expectiation and went on to set a very unrealistic deadline to please the client without even consulting other team members.  In fact, I completely miscalculated the time needed to complete the project. I also failed to predict different complexities along the way. Although I pushed the team really hard, soon it became very clear that the project couldn't be finished within the deadline.
   
   Task:
   So the challeage was how to really finish the project.
   
   Actions:
   I took some actions. 
   Firstly, I had a meeting with the team and admitted it was my fault for the project delay and I asked the team to discuss a more realistic project deadline.  I did a root cause analysis with the team and identified bottlenecks by reviewing the project timeline and checking the main dependencies between tasks. I then worked with the team to make some very realistic estimates to the remaining tasks together, considering some unforseen contigency as well. I also asked each person to voice their concerns or issues. Then I came up with a new timeframe to finish the project, which turned out to be a few weeks longer than the original one.
   
   Secondly I communicated with the client openly, expressed the situation, apologized for the project dealy, and admited now the project couldn't be finished within the deadline, and asked the client to approve the new deadline. The client was not very happy with the delay, but showed understanding of the situation, and agreed to extend the project deadline. 
   
   Result:  
   Finally the project was finished with a few weeks later than the orignal deadline.  The situation was not ideal but it helped me improve my planning skills and distribute tasks in a more efficient way, and this experience also taught me just how crucial it was to have ressonable estimation, and set realistic expectation, so to avoid over promise but under deliver. I also learned the importance of teamwork and open communication. Luckily, I learned from my mistake and it never happened again.
      
## Decisions
1. Tell me about a time that you have to make a decision between standard and delivery?
   
   Situation:    
   There was once a time that we had a production issue that a few products had wrong effective dates and termination dates. It caused one of our largets clients to have done some wrong trades which needed to be revoked. The client was very unhappy and asked the company to solve the issue ASAP.  I was asked to look into the issue and find a fix. I quickly found that these products were generated by the system roughly every three months and the core logic was flawed and hence the system could generate wrong dates from time to time. Ideally these logic of calcuating dates should be fixed so the issue would never appear again. However, that was not easy as the logic was very complex and undoubtedly would take much more time, and involed more risk as well. 
   
   Task:  
   So I was thinking what shall I do? To spend more time to come up with a solution that fixes the rootcause or have a short-time workaround to fix the issue temporariliy first at least? What happened in the past was often times when a issue was fixed by a workaound, it was forgotten and the underlying issue was not fixed, and hence caused grief in the future. For example, at some point, the issue might appear again. So back then, our company had a standard of avoding quick dirty workaround if possible.
   
   Action:  
   After careful consideration, I proposed to have a short-term workaround to fix the issue first, by amending the dates stored in database and then did a system start to pick up the changes. Although this was not a great solution, it solved the problem for roughly 3 months hence could make the client feel much better and avoided futher reputation damage to the platform.
   
   I also created a task to fix the issue more properly by fixing the flawed the logic of generating dates, and asked the management to prioritize the task to be worked in the near future so we didn't forget about it like before. 
   
   Result:  
   The management agreed with my suggestion. So I went on to fix the issue by provoding the workaround and released it in just two days. The client was very pleased with the quick turnraoud. A few days later I was also able to fix the flawed logic of dates generation so the dates would never be wrong again, not only for these products, but also for many other products which shared same logic for generating dates. What I learned sometime it was okay to lower the standard a little bit for quick delivery to address urgent issue but be sure to make change to maintain the standard later so to avoid cuasing issues down the track.
